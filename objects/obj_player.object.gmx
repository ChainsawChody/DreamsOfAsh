<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_playerDown</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>-1</persistent>
  <parentName>obj_lifeform_parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Character Properties
if(instance_number(obj_player) &gt; 1)
{
    instance_destroy();
}

event_inherited();

sprinting = false;
weapon_sprite = spr_stick;
damageModifier = 1;

//Values
image_speed = 0;

//Speeds
spd = 2;        //2
spdwalk = 2;    //2
spdsprint = 5;  //3
spdsneak = 1;   //1

hspd = 0;
vspd = 0;
len = 0;
dir = 0;
xaxis = 0;
yaxis = 0;
imgspd = .2;
glowSize = 1;

//Toggle lantern light
lightOn = "";

//Dialog setup
//ptempspd = "";
//etempspd = "";

state = scr_move_state;
face = RIGHT;
movement = MOVE;
sprintstage = SPRINT;
sneakstage = SNEAK;
boomstage = BOOM;

//Create the sprite array
//Walking sprites
sprite[RIGHT, MOVE] = spr_playerRightW;
sprite[UP, MOVE] = spr_playerUpW;
sprite[LEFT, MOVE] = spr_playerLeftW;
sprite[DOWN, MOVE] = spr_playerDownW;

//Attacking sprites
sprite[RIGHT, ATTACK] = spr_player_attack_right;
sprite[UP, ATTACK] = spr_player_attack_up;
sprite[LEFT, ATTACK] = spr_player_attack_left;
sprite[DOWN, ATTACK] = spr_player_attack_down;

//Boomstick sprites
sprite[RIGHT, BOOM] = spr_player_boomstick_right;
sprite[UP, BOOM] = spr_player_boomstick_up;
sprite[LEFT, BOOM] = spr_player_boomstick_left;
sprite[DOWN, BOOM] = spr_player_boomstick_down;

//Sprinting sprites
sprite[RIGHT, SPRINT] = spr_playerRight;
sprite[UP, SPRINT] = spr_playerUp;
sprite[LEFT, SPRINT] = spr_playerLeft;
sprite[DOWN, SPRINT] = spr_playerDown;

//Sneaking sprites
sprite[RIGHT, SNEAK] = spr_playerRightS;
sprite[UP, SNEAK] = spr_playerUpS;
sprite[LEFT, SNEAK] = spr_playerLeftS;
sprite[DOWN, SNEAK] = spr_playerDownS;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Dash alarm
state = scr_move_state;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set lantern light on player

playercolor = make_colour_rgb(51, 102, 204) //Light blue (153, 204, 255)
lanterncolor = make_colour_rgb(255, 204, 102)
//lanternmix = merge_colour(make_colour_rgb(51, 102, 204), make_colour_rgb(255, 204, 102), 0.5)
lanternmix = make_colour_rgb(162, 158, 149) //merged @ meyerweb.com/eric/tools/color_blend/

if(obj_player.weapon_sprite == spr_lanternweapon)//spr_lantern_lit)
{
    scr_lantern_on();    
}
else
{
    if(room = rm_bridge) or (room = rm_slaughterhouse) or (room = rm_cornfield) or (room = rm_town) or (room = rm_lake) or (room = rm_whiteroom) or (room = rm_dungeon) or (room = rm_cemetary) or (room = rm_asylum)
    {
        /// Set light on player to normal
        size = 1000;
        scr_nightlight();
    }
}
if(room = rm_cell)
{
    scr_maxlight();
}

/* Old lantern effect
if(obj_player.weapon_sprite == spr_lantern_lit)
{
    size = 250; 
    draw_set_blend_mode(bm_subtract);
    surface_set_target(light);
    draw_ellipse_color(x - size / 2 - view_xview, y - size / 2 - view_yview, x + size / 2 - view_xview, y + size / 2 - view_yview, lanterncolor, c_black, false);
    draw_ellipse_color(x - size / 2 - view_xview, y - size / 2 - view_yview, x + size / 2 - view_xview, y + size / 2 - view_yview, playercolor, c_black, false);
    surface_reset_target();
    draw_set_blend_mode(bm_normal);
    instance_destroy(obj_lantern);
}
else
{
    /// Set light on player to normal
    size = 125;
    draw_set_blend_mode(bm_subtract);
    surface_set_target(light);
    draw_ellipse_color(x - size / 2 - view_xview, y - size / 2 - view_yview, x + size / 2 - view_xview, y + size / 2 - view_yview, playercolor, c_black, false);
    surface_reset_target();
    draw_set_blend_mode(bm_normal);
}

//Toggle light off/on
if(obj_player.weapon_sprite == spr_lanternweapon)//spr_lantern_lit)
{

    if (obj_input.light_key)
    {
        if(lightOn)
        {
            lightOn = false;
        }
        else
        {
            lightOn = true;
        }
    }
    if(lightOn = true)
    {
        scr_lantern_on();    
    }
    else
    {
        size = 200;
        scr_lantern_off();
    }
}
else
{
    if(room = rm_bridge) or (room = rm_sawmill) or (room = rm_cornfield) or (room = rm_town) or (room = rm_lake)
    {
        /// Set light on player to normal
        size = 200;
        scr_nightlight();
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// (Backup) Set lantern light on player
/*
playercolor = make_colour_rgb(51, 102, 204) //Light blue (153, 204, 255)
lanterncolor = make_colour_rgb(255, 204, 102)
//lanternmix = merge_colour(make_colour_rgb(51, 102, 204), make_colour_rgb(255, 204, 102), 0.5)
lanternmix = make_colour_rgb(162, 158, 149) //merged @ meyerweb.com/eric/tools/color_blend/

if(obj_player.weapon_sprite == spr_lantern_npc)//spr_lantern_lit)
{
    size = 250 + glowSize; 
    draw_set_blend_mode(bm_subtract);
    surface_set_target(light);
    draw_ellipse_color(x - size / 2 - view_xview, y - size / 2 - view_yview, x + size / 2 - view_xview, y + size / 2 - view_yview, lanterncolor, c_black, false);
    surface_reset_target();
    draw_set_blend_mode(bm_normal);
    
    size = 125;
    draw_set_blend_mode(bm_subtract);
    surface_set_target(light);
    draw_ellipse_color(x - size / 2 - view_xview, y - size / 2 - view_yview, x + size / 2 - view_xview, y + size / 2 - view_yview, playercolor, c_black, false);
    surface_reset_target();
    draw_set_blend_mode(bm_normal);
    instance_destroy(obj_lantern);
}
else
{
    /// Set light on player to normal
    size = 200; //125
    draw_set_blend_mode(bm_subtract);
    surface_set_target(light);
    draw_ellipse_color(x - size / 2 - view_xview, y - size / 2 - view_yview, x + size / 2 - view_xview, y + size / 2 - view_yview, playercolor, c_black, false);
    surface_reset_target();
    draw_set_blend_mode(bm_normal);
}

/*
if(obj_player.weapon_sprite == spr_lantern_lit)
{
    size = 250; 
    draw_set_blend_mode(bm_subtract);
    surface_set_target(light);
    draw_ellipse_color(x - size / 2 - view_xview, y - size / 2 - view_yview, x + size / 2 - view_xview, y + size / 2 - view_yview, lanterncolor, c_black, false);
    draw_ellipse_color(x - size / 2 - view_xview, y - size / 2 - view_yview, x + size / 2 - view_xview, y + size / 2 - view_yview, playercolor, c_black, false);
    surface_reset_target();
    draw_set_blend_mode(bm_normal);
    instance_destroy(obj_lantern);
}
else
{
    /// Set light on player to normal
    size = 125;
    draw_set_blend_mode(bm_subtract);
    surface_set_target(light);
    draw_ellipse_color(x - size / 2 - view_xview, y - size / 2 - view_yview, x + size / 2 - view_xview, y + size / 2 - view_yview, playercolor, c_black, false);
    surface_reset_target();
    draw_set_blend_mode(bm_normal);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move the player step event / lantern effect
depth = -y;
script_execute(state);

sprite_index = sprite[face, movement];

//Glow effect
var dif = choose(-5, 5, 0); //(0.01, -0.01, 0);
glowSize += dif;
glowSize = clamp(glowSize, -5, 5);

//Destroy dialog when out of range
if(instance_exists(obj_dialog))
{
    if(point_distance(obj_dialog.x, obj_dialog.y, obj_player.x, obj_player.y) &gt; 30)
    {
        //show_message("Too far.")
        with(obj_dialog)
        {
            instance_destroy();
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_door">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Go through door
if (room_exists(other.new_room))
{
    room_goto(other.new_room);
    x = other.new_x;
    y = other.new_y;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_enemy_lifeform">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Collide
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change back to move state
if (state == scr_attack_state or state == scr_boom_state)
{
    state = scr_move_state;
    attacked = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set fixed rotation / stop intro audio
phy_fixed_rotation = true;
persistent = true;

//stop intro audio
audio_stop_sound(snd_forestintro)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create debug
instance_create(x, y, obj_debug);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>-1</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>1</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>5</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>2,10</point>
    <point>12,10</point>
    <point>12,20</point>
    <point>2,20</point>
  </PhysicsShapePoints>
</object>
